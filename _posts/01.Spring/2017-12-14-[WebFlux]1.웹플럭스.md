스프링 프레임워크를 만든 Pivotal에서는 사용자가 보다 손쉽게 비동기 논블럭킹 작업을 구현할 수 있도록 리액티브 구현체인 Project Reactor를 스프링에 적용하는 작업을 진행했고, 그 결과물로 Spring Reactive Web(spring-webflux)을 만들었습니다. 이제 Spring Reactive Web을 통해 스케줄링, 스레드 풀정책 설정 등을 하지 않고 최적화된 성능의 논블럭킹 비동기 웹환경을 구현할 수 있습니다. 
**[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)

옵저버 패턴의 발전된 방식으로 구현됩니다. 
데이터를 전달하는 객체에 데이터를 받고자 하는 객체를 등록하고, Spring Reactive Web 데이터가 들어오면(event) 등록된 객체들에게 데이터를 전달하는 기본 기능과 비동기 동작 구현을 위한 여러가지 기능들을 제공합니다.

[**[출처\]** ](http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=221096039961&redirect=Dlog&widgetTypeCall=true&directAccess=false#)[릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



스프링에 적용된 리액티브 라이브러리는 Reactor입니다. (https://projectreactor.io/)
Spring Reactive Web 은 이 Reactor를 이용해 스프링 웹환경을 제공합니다. 기존 Spring Web 을 대체하기 때문에 스프링 리액티브 프로젝트 생성 시 Spring Web 은 dependency 가 없어야 합니다. **[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



다만, 기존에 구현된 웹환경을 Spring Reactive Web 으로 변경할 경우, 성능향상과 유지보수에 도움이 될지는 잘 따져봐야 합니다. 비동기 동작이 강제되다 보니, 코드가 순차적이지 않아서 디버깅 시 어려움도 있을 것이고, 동작 중간에 블럭킹 동작(ex. DB 접근)이 일어나는 부분 구간이 있다면 Spring Reactive Web을 통해 성능 향상을 기대하기 어려울 수 있으므로 기존 웹환경이 Spring Reactive Web 에 적합할지 검토가 필요합니다.**[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



### Spring WebFlux framework

Spring WebFlux는 Spring Framework 5에 포함된 새로운 웹 애플리케이션 프레임워크다. 기존 Spring MVC 모델에 비동기(asynchronous)와 넌블럭킹 I/O(non-blocking I/O) 처리를 맡기려면 너무 큰 변화가 필요했기 때문에 [리액티브 프로그래밍(Reactive programming)](https://en.wikipedia.org/wiki/Reactive_programming)을 지원하는 새로운 웹 프레임워크를 만들었다고 한다.

Spring MVC와 Spring WebFlux는 다음과 같은 구조로 되어 있다.



MVC는 서블릿 컨테이너와 서블릿을 기반으로 웹 추상화 계층을 제공하고, WebFlux는 서블릿 컨테이너(Tomcat, Jetty) 외에도 [Netty](https://netty.io/), [Undertow](http://undertow.io/)와 같이 네트워크 애플리케이션 프레임워크 위에서 HTTP와 [리액티브 스트림(Reactive Streams)](http://www.reactive-streams.org/) 기반으로 웹 추상화 계층을 제공하고 있다.

MVC와 WebFlux 둘다 @Controller, @RequestMapping 형태에 @MVC 모델을 그대로 사용할 수 있다. WebFlux는 [Route Functions](http://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html#_routerfunctions)이라는 함수형 프로그래밍 방식에 모델을 추가로 제공한다.



## WebFlux는 어떻게 동작하나?

MVC는 다음과 같이 요청과 응답을 처리하고 있다.

[이미지][^img/2.png]

서블릿 컨테이너로 들어온 요청이 DispatcherServlet에게 전달되면, DispatcherServlet는 순차적으로 HandlerMapping, HandlerAdapter에게 요청 처리를 위임하고, ViewResolver에게 응답 처리을 위임한다.

WebFlux도 크게 달라지진 않는다. 처리 흐름을 간단하게 도식화해서 보면 아래와 같다.

[이미지][^img/3.png]

웹 서버(서블릿 컨테이너, Netty, Undertow)로 들어온 요청이 HttpHandler에게 전달되면, HttpHandler는 전처리 후 WebHandler에게 처리를 위임한다. WebHandler 내부에서는 HandlerMapping, HandlerAdapter, HandlerResultHandler 3가지 컴포넌트가 요청과 응답을 처리한다. 처리가 끝나면 HttpHandler는 후처리 후 응답을 종료한다. HandlerMapping, HandlerAdapter는 MVC가 사용하는 컴포넌트와 역할과 이름이 같지만, 동작 방식이 다르기 때문에 별도의 인터페이스를 사용한다.

> MVC:
>
> - org.springframework.web.servlet.HandlerMapping
> - org.springframework.web.servlet.HandlerAdapter
>
> WebFlux:
>
> - org.springframework.web.reactive.HandlerMapping
> - org.springframework.web.reactive.HandlerAdapter

MVC와 다른 점은 응답을 처리하는 컴포넌트가 HandlerResultHandler라는 것이다. HandlerResultHandler는 몇 가지 구현체가 제공되는데, 그 중 ViewResolver를 사용하는 ViewResolutionResultHandler가 있다.



함수형의 MVC설정이 가능해진 것도 변화 중 하나지만 다른 큰 변화라면 Reactive Programming 을 지원하는 것이다.

Mono & Flux 클래스 추가

- Publisher 클래스

- Mono : 하나의 요소를 다룰 때

- Flux : 하나 이상의 요소를 다룰 때

- value를 지니고 있는 컨테이너 클래스.

- publisher인데 Mono와 Flux로 객체 생성(데이터 stream 생성)은 어떻게 해야하나?

- - Optional과 동일하게 JPA로 구성시 자동으로 Flux나 Mono로 감쌀 수 있다. (Flux로 감싸는 경우 Flux<List<Object>> 가 아니라 Flux<Object> 이다.)
  - 아니면 just라는 메소드를 통해 객체를 생성할 수 있다.

Mono & Flux 는 모나드 클래스이면서 Publisher 이다.

값이 컨테이너에 담겨있기 때문에 값을 꺼내는 함수를 써야한다. 그런데 Publisher이기 때문에 Subscriber에 의해 구독되기 전에 값을 꺼내지 못한다.

Spring web-flux 에서 Mono나 Flux를 리턴해주면 저절로 subscribe 해준다. 

출처: 

http://jess-m.tistory.com/21

 [Jess's Home]



궁금해서 코드를 쭉 따라가본, 간략한 web-flux 의 Mono, Flux 처리 프로세스

- 기본적인 Dispatch 처리 과정은 spring mvc와 비슷한것 같다.
- DispatcherHandler 이 초기화될때 mvc의 전략 빈들을 주입. (아래의 3개 인터페이스는 스프링 4버전대의 인터페이스와 다르다)
  - 디폴트 빈들은 @EnableWebFlux 을 사용하면서 객체 생성이 될 것이다. 
  - 디폴트 빈에 대한 설정은 WebFluxConfigurationSupport 클래스에서 확인할 수 있다.
  - DispatcherHandler가 초기화할때 스프링 컨텍스트 내에 있는 빈들에서 해당 인터페이스 빈들을 불러들여 주입시킨다.
  - HandlerMapping : Request와 핸들러(메소드) 객체 매핑을 정의하는 인터페이스
  - HandlerAdapter : HandlerMapping이 핸들러(메소드)를 찾아주면, HandlerAdpter가 해당 컨트롤러의 핸들러에 전달하기 위한 Adapter 인터페이스
  - ResultHandler : HandlerAdapter 에 의해 반환된 값을 처리하기 위한 인터페이스
- netty 동작 기반은 더 살펴볼 예정. 
  - NioEventLoop
- 어쨋든 request가 오면 DispatcherHandler의 handle(ServerWebExchange exchange) 메소드를 호출한다.       (ServerWebExchange는 HTTP 요청/응답에 대한 인터페이스)
- 여기서 체이닝걸려있는 함수를 거치며 결과를 반환하게 되는데...
  - 적절한 핸들러를 찾는다.
  - 핸들러를 실행한다.
    - 주입된 핸들러 아답터들을 순회하며 적절한 아답터를 찾는다. (supports)
    - 아답터를 통해서 핸들러 handle
  - 결과를 반환한다.
    - 주입된 resultHandler들 중 적절한 핸들러를 찾음.
    - 핸들러가 handleResult 한다. (결과를 뽑음)
    - @ResponseBody의 핸들러 중 Mono로 반환되는 경우를 예로 보면, ResponseBodyResultHandler 라는 클래스가 handleResult 메소드를 호출하여 결과값을 생성하여 write 한다.

 

출처: 

http://jess-m.tistory.com/21

 [Jess's Home]

### 참조

- https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
- http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=221096039961&redirect=Dlog&widgetTypeCall=true&directAccess=false
- https://github.com/arawn/building-serverless-application-with-spring-webflux
- http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7766819
- https://ahea.wordpress.com/2017/02/15/spring-reactive/
- http://atin.tistory.com/626
- http://jess-m.tistory.com/21
- http://whiteship.me/?page=327
- https://durtchrt.github.io/blog/english/spring.io/webflux/
- https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux
- https://projectreactor.io/docs/core/release/reference/#flux
- https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-new-framework