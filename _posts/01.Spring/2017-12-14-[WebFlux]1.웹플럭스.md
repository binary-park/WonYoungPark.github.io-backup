스프링 프레임워크를 만든 Pivotal에서는 사용자가 보다 손쉽게 비동기 논블럭킹 작업을 구현할 수 있도록 리액티브 구현체인 Project Reactor를 스프링에 적용하는 작업을 진행했고, 그 결과물로 Spring Reactive Web(spring-webflux)을 만들었습니다. 이제 Spring Reactive Web을 통해 스케줄링, 스레드 풀정책 설정 등을 하지 않고 최적화된 성능의 논블럭킹 비동기 웹환경을 구현할 수 있습니다. 
**[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)

옵저버 패턴의 발전된 방식으로 구현됩니다. 
데이터를 전달하는 객체에 데이터를 받고자 하는 객체를 등록하고, Spring Reactive Web 데이터가 들어오면(event) 등록된 객체들에게 데이터를 전달하는 기본 기능과 비동기 동작 구현을 위한 여러가지 기능들을 제공합니다.

[**[출처\]** ](http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=221096039961&redirect=Dlog&widgetTypeCall=true&directAccess=false#)[릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



스프링에 적용된 리액티브 라이브러리는 Reactor입니다. (https://projectreactor.io/)
Spring Reactive Web 은 이 Reactor를 이용해 스프링 웹환경을 제공합니다. 기존 Spring Web 을 대체하기 때문에 스프링 리액티브 프로젝트 생성 시 Spring Web 은 dependency 가 없어야 합니다. **[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



다만, 기존에 구현된 웹환경을 Spring Reactive Web 으로 변경할 경우, 성능향상과 유지보수에 도움이 될지는 잘 따져봐야 합니다. 비동기 동작이 강제되다 보니, 코드가 순차적이지 않아서 디버깅 시 어려움도 있을 것이고, 동작 중간에 블럭킹 동작(ex. DB 접근)이 일어나는 부분 구간이 있다면 Spring Reactive Web을 통해 성능 향상을 기대하기 어려울 수 있으므로 기존 웹환경이 Spring Reactive Web 에 적합할지 검토가 필요합니다.**[출처]** [릴리즈 임박! 스프링 5 리액티브 프로그래밍 소개](http://blog.naver.com/tmondev/221096039961)|**작성자** [개발몬스터](http://blog.naver.com/tmondev)



### Spring WebFlux framework

Spring WebFlux는 Spring Framework 5에 포함된 새로운 웹 애플리케이션 프레임워크다. 기존 Spring MVC 모델에 비동기(asynchronous)와 넌블럭킹 I/O(non-blocking I/O) 처리를 맡기려면 너무 큰 변화가 필요했기 때문에 [리액티브 프로그래밍(Reactive programming)](https://en.wikipedia.org/wiki/Reactive_programming)을 지원하는 새로운 웹 프레임워크를 만들었다고 한다.

Spring MVC와 Spring WebFlux는 다음과 같은 구조로 되어 있다.



MVC는 서블릿 컨테이너와 서블릿을 기반으로 웹 추상화 계층을 제공하고, WebFlux는 서블릿 컨테이너(Tomcat, Jetty) 외에도 [Netty](https://netty.io/), [Undertow](http://undertow.io/)와 같이 네트워크 애플리케이션 프레임워크 위에서 HTTP와 [리액티브 스트림(Reactive Streams)](http://www.reactive-streams.org/) 기반으로 웹 추상화 계층을 제공하고 있다.

MVC와 WebFlux 둘다 @Controller, @RequestMapping 형태에 @MVC 모델을 그대로 사용할 수 있다. WebFlux는 [Route Functions](http://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html#_routerfunctions)이라는 함수형 프로그래밍 방식에 모델을 추가로 제공한다.



## WebFlux는 어떻게 동작하나?

MVC는 다음과 같이 요청과 응답을 처리하고 있다.

[이미지][^img/2.png]

서블릿 컨테이너로 들어온 요청이 DispatcherServlet에게 전달되면, DispatcherServlet는 순차적으로 HandlerMapping, HandlerAdapter에게 요청 처리를 위임하고, ViewResolver에게 응답 처리을 위임한다.

WebFlux도 크게 달라지진 않는다. 처리 흐름을 간단하게 도식화해서 보면 아래와 같다.

[이미지][^img/3.png]

웹 서버(서블릿 컨테이너, Netty, Undertow)로 들어온 요청이 HttpHandler에게 전달되면, HttpHandler는 전처리 후 WebHandler에게 처리를 위임한다. WebHandler 내부에서는 HandlerMapping, HandlerAdapter, HandlerResultHandler 3가지 컴포넌트가 요청과 응답을 처리한다. 처리가 끝나면 HttpHandler는 후처리 후 응답을 종료한다. HandlerMapping, HandlerAdapter는 MVC가 사용하는 컴포넌트와 역할과 이름이 같지만, 동작 방식이 다르기 때문에 별도의 인터페이스를 사용한다.

> MVC:
>
> - org.springframework.web.servlet.HandlerMapping
> - org.springframework.web.servlet.HandlerAdapter
>
> WebFlux:
>
> - org.springframework.web.reactive.HandlerMapping
> - org.springframework.web.reactive.HandlerAdapter

MVC와 다른 점은 응답을 처리하는 컴포넌트가 HandlerResultHandler라는 것이다. HandlerResultHandler는 몇 가지 구현체가 제공되는데, 그 중 ViewResolver를 사용하는 ViewResolutionResultHandler가 있다.



함수형의 MVC설정이 가능해진 것도 변화 중 하나지만 다른 큰 변화라면 Reactive Programming 을 지원하는 것이다.

Mono & Flux 클래스 추가

- Publisher 클래스

- Mono : 하나의 요소를 다룰 때

- Flux : 하나 이상의 요소를 다룰 때

- value를 지니고 있는 컨테이너 클래스.

- publisher인데 Mono와 Flux로 객체 생성(데이터 stream 생성)은 어떻게 해야하나?

- - Optional과 동일하게 JPA로 구성시 자동으로 Flux나 Mono로 감쌀 수 있다. (Flux로 감싸는 경우 Flux<List<Object>> 가 아니라 Flux<Object> 이다.)
  - 아니면 just라는 메소드를 통해 객체를 생성할 수 있다.

Mono & Flux 는 모나드 클래스이면서 Publisher 이다.

값이 컨테이너에 담겨있기 때문에 값을 꺼내는 함수를 써야한다. 그런데 Publisher이기 때문에 Subscriber에 의해 구독되기 전에 값을 꺼내지 못한다.

Spring web-flux 에서 Mono나 Flux를 리턴해주면 저절로 subscribe 해준다. 

출처: 

http://jess-m.tistory.com/21

 [Jess's Home]



궁금해서 코드를 쭉 따라가본, 간략한 web-flux 의 Mono, Flux 처리 프로세스

- 기본적인 Dispatch 처리 과정은 spring mvc와 비슷한것 같다.
- DispatcherHandler 이 초기화될때 mvc의 전략 빈들을 주입. (아래의 3개 인터페이스는 스프링 4버전대의 인터페이스와 다르다)
  - 디폴트 빈들은 @EnableWebFlux 을 사용하면서 객체 생성이 될 것이다. 
  - 디폴트 빈에 대한 설정은 WebFluxConfigurationSupport 클래스에서 확인할 수 있다.
  - DispatcherHandler가 초기화할때 스프링 컨텍스트 내에 있는 빈들에서 해당 인터페이스 빈들을 불러들여 주입시킨다.
  - HandlerMapping : Request와 핸들러(메소드) 객체 매핑을 정의하는 인터페이스
  - HandlerAdapter : HandlerMapping이 핸들러(메소드)를 찾아주면, HandlerAdpter가 해당 컨트롤러의 핸들러에 전달하기 위한 Adapter 인터페이스
  - ResultHandler : HandlerAdapter 에 의해 반환된 값을 처리하기 위한 인터페이스
- netty 동작 기반은 더 살펴볼 예정. 
  - NioEventLoop
- 어쨋든 request가 오면 DispatcherHandler의 handle(ServerWebExchange exchange) 메소드를 호출한다.       (ServerWebExchange는 HTTP 요청/응답에 대한 인터페이스)
- 여기서 체이닝걸려있는 함수를 거치며 결과를 반환하게 되는데...
  - 적절한 핸들러를 찾는다.
  - 핸들러를 실행한다.
    - 주입된 핸들러 아답터들을 순회하며 적절한 아답터를 찾는다. (supports)
    - 아답터를 통해서 핸들러 handle
  - 결과를 반환한다.
    - 주입된 resultHandler들 중 적절한 핸들러를 찾음.
    - 핸들러가 handleResult 한다. (결과를 뽑음)
    - @ResponseBody의 핸들러 중 Mono로 반환되는 경우를 예로 보면, ResponseBodyResultHandler 라는 클래스가 handleResult 메소드를 호출하여 결과값을 생성하여 write 한다.



출처: 

http://jess-m.tistory.com/21



# 리액티브 사용 사례

 

새로 시작하는 개발자들이 대답을 듣기 어려운 질문은 "그래서 뭐가 좋다는 거야?"일 것이다. 이제 몇 가지 엔터프라이즈 환경에서의 일반적인 사용 패턴을 살펴보자.

 

**외부 서비스 호출(External Service Call)**

요즘의 많은 백엔드 서비스들은 REST 방식(즉 HTTP 기반으로 동작한다)이며 그래서 기반 프로토콜은 기본적으로 응답을 대기(blocking)해야 하고 동기적(synchronous)으로 수행된다. 여기에 FRP가 비빌 언덕이 없어보이지만, 사실 이 지점이야말로 FRP가 적용될 수 있는 부분이다. 그 이유는 이런 서비스들은 또 다른 서비스들을 호출하도록 구현되며, 그래서 수많은 서비스들이 첫 번째 호출의 결과와 관련있기 때문이다. 수많은 입출력(IO)가 수행되는 과정에서, 만약 어떤 요청을 전송하기 전에 다른 호출이 완료되기를 기다려야 한다면, 서비스 사용자는 응답 데이터가 만들어지기도 전에 좌절하여 포기할 수도 있다. 그렇기 때문에 외부 서비스를 호출하는 경우, 특히 그 서비스 호출들이 복잡하게 연결되어 있는 경우야 말로 최적화하기 좋은 지점이 된다. FRP는 이러한 동작들을 수행하는 로직을 조합할 수 있도록 보장하며, 그래서 개발자들은 서비스를 호출하는 코드를 쉽게 작성할 수 있다.

 

**높은 동시성 메세지 소비자(Highly Concurrent Message Consumers)**

메세지 프로세싱은, 특히 고도의 동시 처리를 수행한다는 점에서 엔터프라이즈 어플리케이션에서 흔히 사용된다. 리액티브 프레임워크들은 마이크로 벤치마크를 측정하여 JVM 내에서 1초당 수없이 많은 메세지를 처리할 수 있는지 보여주기를 좋아한다. 벤치마크 결과는 믿기 어려울 정도로 놀라운데(초당 수천만 메세지들이 쉽사리 처리된다), 사실 다소 인위적인 결과일 수 있다. - 벤치마크 테스트를 위해 단순한 for 반복문을 사용했다고 한다면 그다지 감동적이지 않을 것이기 때문이다. 그렇다고 해서 이런 시도를 섣불리 그만둬서는 안 되는데, 성능이 문제가 되는 경우는 흔하며 그런 경우 (성능 향상을 위한) 모든 기여는 감사히 받아들여지기 때문이다. 리액티브 패턴들은 (이벤트가 멋지게 메세지로 번역되기 때문에) 메세지 프로세싱과 자연스럽게 들어맞으며, 그래서 보다 많은 메세지들을 처리하는 방법이 있기만 하다면 주의를 기울일 필요가 있다.

 

**스프레드시트(SpreadSheet)**

스프레드시트는 엔터프라이즈 어플리케이션은 아니지만, 엔터프라이즈 환경에서 일하는 모든 사람들은 이에 관련되어 있고, FRP의 철학과 FRP 구현의 어려움을 잘 이해하는 데에 도움을 준다. 만약 B셀이 A셀에 의존하고 있고, C셀이 A셀과 B셀 모두에 영향을 받는 상황을 생각해보자. 어떻게 하면 어떤 변화 이벤트도 B에 전달되기 전에 C가 갱신될 것을 보장하면서 A의 변화를 전파할 수 있을까? 만약 당신이 사용하는 프레임워크가 매우 액티브하다면 단순히 "걱정할 필요 없다. 그저 의존관계를 선언하기만 하면 된다."라고 말할 것이고, 이것이 바로 요컨대 스프레드시트 프로그램의 진정한 힘일 것이다. 이 부분이 FRP와 단순한 이벤트 드리븐 프로그래밍의 차이를 보여주는 것이라 할 수 있다. - FRP는 "지능형 라우팅(intelligent routing)"에 지능을 부여한다.

 

**(비)동기 처리에 대한 추상화(Abstraction Over (A)synchronous Processing)**

이것은 다소 추상적인 사용예이고, 그래서 피해야 할 영역에 들어서는 것이 수도 있다. 여기에는 지금까지 언급했던 내용들과 (매우 많이) 겹치는 부분이 있지만, 그래도 다뤄볼 만 할 것이다. 첫 번째 내용은 친숙한 (그리고 타당한) 것인데, 개발자들이 추가적인 추상 계층을 받아들일 수만 있다면, 자신이 호출하는 코드가 동기적이든 비동기적이든 신경쓰지 않아도 된다는 것이다. 비동기 프로그래밍을 다룬다는 것이 뇌에 과부하를 주는 것이기 때문에 이런 발상은 꽤 유용하다고 할 수 있다. 리액티브 프로그래밍이 이런 이슈를 해결하는 유일한 방법은 아니지만, FRP의 구현자들은 그들이 만든 도구들이 유용할 수 있도록 이에 대해 충분히 고려해왔다.

























### 참조

- https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
- http://blog.naver.com/PostView.nhn?blogId=tmondev&logNo=221096039961&redirect=Dlog&widgetTypeCall=true&directAccess=false
- https://github.com/arawn/building-serverless-application-with-spring-webflux
- http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7766819
- https://ahea.wordpress.com/2017/02/15/spring-reactive/
- http://atin.tistory.com/626
- http://jess-m.tistory.com/21
- http://whiteship.me/?page=327
- https://durtchrt.github.io/blog/english/spring.io/webflux/
- https://docs.spring.io/spring-framework/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux
- https://projectreactor.io/docs/core/release/reference/#flux
- https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-new-framework