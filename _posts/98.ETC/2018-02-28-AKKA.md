---
layout: post
title: "Illegal key size 에러 해결방안 및 JCE 정책 변경"
subtitle: "Java"
categories: document
tags: java akka 비동기
published: false
comments: true
---

> 이 글은 [Akka 코딩 공작소](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=114165297)를 요약 및 정리하여 작성한 내용임을 밝힙니다. 필자가 작성하는 내용은 책의 내용을 그대로 사용하여 작성한 부분도 많지만 인용하여 작성한 부분도 있기 때문에 보다 정확하고 자세한 내용을 위해 해당 책을 구매하여 보시는 것을 추천드립니다.



현재 사내에서 Spring5에서 추가 된 Webflux 모듈을 사용해서 API Server를 구축하고 있습니다. 필자는 기존에 MVC 구조의 Servlet 컨테이너 기반의 프로젝트밖에 경험해 본적이 없기 때문에 이벤트기반의 비동기/논블럭킹 프로그래밍을 경험해 본적이 없었습니다. 그로 인해 Webflux에 대한 러닝커브가 높았으며, 아직 정식 릴리즈가 되지 못한 시점이기 때문에 관련 자료들도 부족하여 정확한 개념을 잡는것이 어려움을 느끼고 있었던 중 Akka를 알게 되었습니다. 최근에 많이 대두되고 있는 리액티브 프로그래밍인 akka, RxJava, Spring Webflux등은 모두 지향하는 바가 같기 때문에 [Akka 코딩 공작소](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=114165297)를 통해 리액티브 프로그래밍의 개념과 원리를 파악하는데 중점을 두고자 합니다.([Akka 코딩 공작소](http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=114165297)의 모든 내용은 다루지 않고 리액티브 프로그래밍의 주요 개념과 원리만을 정리할 예정입니다.)



## 1. 아카소개

오늘 날 흔히 사용하는 도구(스레드와 RPC)를 활용해 시스템의 복잡도는 낮추고, 애플리케이션의 규모를 확장성이 좋게 만들수 있을까요? RPC를 사용해 수평으로 규모를 확장하고, 저수준 스레드를 사용해 수직으로 규모를 확장하는 것은 좋은 생각이 아닙니다.

RPC는 네트워크를 통한 호출이 로컬 메서드 호출과 다르지 않은 척하는 것입니다. 그래서 이렇게 추상화된 로컬 메서드 호출이 제대로 작동하려면 현재 스레드를 **블록(block)** 네트워크에서 도착하는 응답을 기다려야만 합니다. 이때 상당한 비용이 들며. 이는 자원을 효율적으로 사용해야 하는것을 방해합니다.

> **비용과 효율이 중요하다. 또한 모든 것은 애플리케이션의 규모를 효과적으로 확장할 수 있어야 한다.**



### 1.1. 아카란?

아카는 라이트벤드(LightBend)사에서 만든 오픈소스 프로젝트이다. 아카는 더 단순한 단일 프로그래밍 모델인 **액터 프로그래밍 모델**을 제공합니다.(동시/분산 애플리케이션을 코딩하는 방식중 한가지) 아카는 자원을 효율적으로 활용하며 애플리케이션이 커져도 복잡도를 상대적으로 낮게 유지할 수 있습니다.



### 1.2. 액터란?

액터는 설정과 메시지 브로커 설치라는 부가 비용이 들지 않는 메시지큐와 상당히 비슷합니다.. 액터는 프로그래밍 가능한 메시지 큐를 아주 작은 크기로 줄인 것과 같습니다. 각 액터는 메시지를 받기 전까지는 아무런 일도 수행하지 않는다.

메시지는 일단 생성된 다음에는 변경될 수 없는 간단한 데이터 구조입니다. 이를 불편(immutable)이라는 단어로 말합니다.

액터는 한 번에 하나의 메시지를 받을 수 있으며, 메시지를 받을 때마다 어떠한 동작을 수행합니다. 대기열과 다르게 액터가 (다른 액터에게) 메시지를 보낼 수도 있습니다.

액터가 수행하는 모든 것은 비동기적으로 실행됩니다. 간단히 말해, 여러분은 응답을 기다리지 않고 액터에게 메시지를 보낼 수 있습니다. 액터는 스레드와는 다르지만, 액터에 전달한 메시지는 언젠가는 스레드를 거쳐서 들어갑니다.



### 1.3. 반응형 선언문

반응형 선언문은 더 튼튼하며, 더 회복성 좋고, 더 유연하며, 최근의 요구사항에 더 부합하는 시스템을 설계하게 하자는 운동이다.

요약하자면, 자원을 효율적으로 사용하고, 애플리케이션이 자동으로 확장(탄력성)할 기회를 더 많이 주는 것이 선언문을 이끄는 큰 동인이다.

- 블로킹 I/O를 사용하면 병렬성을 살릴 기회가 줄어든다. 따라서 논블로킨 I/O를 선호한다.
- 동기 상호 작용을 벙렬성 기회를 줄인다. 따라서 비동기 상호 작용을 선호한다.
- 폴링(polling)은 자원을 적게 쓸 기회를 줄인다. 따라서 이벤트 기반 처리를 선호한다.
- 어떤 노드가 다른 모든 노드를 중단시킬 가능성이 있다면 자원이 낭비될 것이다. 따라서 진행 중인 모든 작업을 잃어버리는 일이 없도록 오류를 격리해야 한다.(회복성)
- 시스템은 탄력적이어야 한다. 요청이 적다면 자원을 더 적게 사용하기를 바랄 것이다. 요청이 많다면 자원을 더 많이 사용하라. 하지만 필요한 것보다 많은 양을 사용해서는 안 된다.



### 수직/수평 확장을 동시에 할 수 있다

범용 프로그래밍 언어는 대부분 순서대로 프로그램을 작성합니다. 이런 순차 정의와 병렬 실행 사이의 차이를 메꾸기 위해서는 동시성 프로그래밍 모델이 필요합니다.

병렬성은 프로세서를 동시에 실행하는 것이 관한 문제인 반면, 동시성은 동시에 기능할 수 있는 프로세스를 정의하는 데 관심이 있습니다. **하지만 꼭 각각을 동시에 실행 할 필요는 없습니다.** 동시성 시스템은 정의에 따르면 병렬 시스템이 아닙니다.

무슨 말인지 모르겠다...



### 비동기 모델

애플리케이션을 수평확장하기 용이하도록 구성하기 위해서 중요한 요구사항이 있다면 그것은 **비동기적**이여야 한다는 것입니다. 최근 MSA 처럼 다수의 애플리케이션이 상호통신을 통해 하나의 프로세스가 처리되는 환경에서 동기 통신을 사용해서 매번 모든 애플리케이션의 모든 응답을 기다린다면, 하나의 애플리케이션에서 장애가 발생하였을 경우 블로킹이 발생하여 시스템이 마비되는 최악의 현상이 발생할 수 있습니다.



### ~~액터 연산~~

~~액터는 생성, 송신, 상태변화, 감독 이라는 네가지 핵심 연산만을 제공하는 경량 프로세스 입니다. 이런 모든 연산은 비동기적입니다.~~

#### ~~송신~~

~~액터가 다른 액터와 의사소통하는 방법은 오직 **메시지를 보내는 방법 밖에 없습니다.** 메시지는 항상 비동기적이며, 메시지 송신 후 발사 후 망각 스타일로 이루어 집니다. 액터는 다른 액터에게 보낸 다음 어떤 작업들이 이루어 지는지 알 필요가 없습니다. 즉, 메시지를 송신한 후 다시 자신의 일을 진행할 수 있습니다. 또한 전통적인 방식에서 사용한 메시지큐를 사용하지 않더라도 애플리케이션 간에 연결을 분리할 수 있습니다.~~

~~메시지는 변경 불가능해야 합니다. 즉, 메시지를 생성한 다음에 그 내용을 바꿀 수 없어야 합니다. 왜냐하면 두 액터가 같은 메시지를 동시에 변경하는 것을 피하기 위해서 입니다. 같은 메시지를 두 액터가 동시에 변경한다면 예측할 수 없는 장애가 발생할 수 있습니다.~~

#### ~~생성~~

~~액터는 다른 액터를 생성할 수 있습니다.~~

#### ~~상태 변화~~

~~상태기계는 어떠한 시스템이 특정 상태에 있을 때만 특정 동작을 수행하도록 보장하고 싶을 때 사용되는 훌륭한 도구입니다. 액터는 한 번에 메시지를 하나씩만 받습니다. 이는 상태 기계를 구현하는데 아주 편리한 특성입니다.~~

#### ~~감독~~

~~액터는 자신이 만든 다른 액터를 감독해야 합니다.~~



### 콜백지옥

대부분 프레임워크는 비동기 프로그래밍을 할 때 콜백을 사용합니다. 콜백 지옥이란 콜백이 다른 콜백을 호출하고 그 콜백이 다시 다른 콜백을 호출하는 코드를 일커르며, 콜백 지옥은 코드의 가독성을 떨어트리고 개발자의 실수로 인해 시스템 장애가 발생할 가능성이 높아집니다.

액터는 이러한 콜백 지옥이 발생하지 않도록 디스패처가 내부적으로 모든 작업을 처리하여, 개발자는 콜백 지옥으로 인해 발생하는 복잡도에 해방될 수 있습니다.



## 요약

전통적인 접근 방법을 사용해서 제대로 규모를 확장하기란 쉬운일이 아닙니다. 규모가 커지면서 복잡도와 경직성이 제어할 수 없을 만큼 빠르게 증가하게 됩니다. 액터는 모든 것을 메시지를 보내고 받는 것을 중심으로 이루어져 있습니다.