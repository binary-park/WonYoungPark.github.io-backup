---
layout: post
title: "객체지향 생활체조-규칙9"
subtitle: "Java"
categories: document
tags: java
comments: true
---

>해당 글은 [developerFarm 개발자 블로그의 농장객체지향 생활체조](https://developerfarm.wordpress.com/2012/02/03/object_calisthenics_summary)를 참고하여 정리한 글 입니다.

###규칙9. 게터/세터/속성 사용 금지

앞의 규칙의 마지막 문장은 거의 바로 이 규칙으로 이어진다. 만약 객체가 지금 인스턴스 변수의 적당한 집합을 캡슐화하고 있지만 그 설계가 여전히 어색하다면, 좀 더 직접적인 캡슐화 위반을 조사해볼 때다. 그냥 단순히 현재 위치에서의 값을 물을 수 있는 동작이라면 해당 인스턴스 변수를 제대로 따라가지 못할 것이다. 강한 캡슐화 경계의 바탕에 깔린 사상은 동작의 검색과 배치를 위해 남겨둔 코드를 만질 다른 프로그래머를 위해 객체 모델의 단일한 지점으로 유도하려는 것이다. 이는 많은 긍정적인 하부효과를 가져다 주는데, 중복 오류의 극적 축소와 새 기능의 구현을 위한 변경의 지역화 개선 등이 있다.

이 규칙은 흔히 “말을 해, 묻지 말고”라고 일컫는다.



## **결론**

지금까지 다룬 9가지 규칙 가운데 8가지는 간단히 말해 객체지향 프로그래밍이라는 성배(Holy Grail), 즉 데이터의 캡슐화를 가시화하고 실현하기 위한 방안이다. 더불어, 또 하나는 다형성의 적절한 사용(else를 쓰지 않고 모든 조건 논리를 최소화하는 것)을 유도하며, 또 하나는 간결하고 직설적인 명명 표준을 장려하는, 일관성 없이 적용되며 발음하기 어려운 축약어를 배제한 명명 전략이다.

최종 요점은 코드나 아이디어의 중복이 없게 코드를 빚는 것이다. 목표는 우리가 온종일 풀어야 하는 일상의 복잡다단함에 대한 단순하고 우아한 추상화를 간결하게 표출하는 코드다.

궁극적으로는 결국 어떤 경우 규칙들 간에 모순을 일으키며 퇴보된 결과를 낳는 것을 보게 될 것이다. 그러나 이 연습을 위해 20시간을 써서 이 규칙에 100% 부합하는 코드 1000줄을 짜보라. 낡은 습관을 버리고 그동안 프로그래머로의 인생을 통틀어 지녀왔을지 모르는 규칙에 변화를 가해야만 하는 자기 자신을 발견하게 될 것이다. 각 규칙은 그렇게 엄선했고, 따라서 규칙을 따르면 자기에게는 쓸 수 없는 분명한 (그러나 어쩌면 틀린) 해답이 으레 존재하는 상황을 조우할 것이다.

이들 규칙을 훈려과 더불어 따르면 객체지향 프로그래밍을 더 많이 이해할 수 있는 더 탄탄한 문제 해결책을 자기 것으로 만들게 되리라 본다. 이 모든 규칙을 따른 1000줄짜리 코드를 짜면 예상했던 것과는 완전히 다른 무언가를 짰다는 것을 깨닫게 된다. 규칙을 따르고, 어디서마쳤는지를 확인하라. 계속 그렇게 일한다면 작성 중인 코드는 어떤 의식적인 노력을 스스로 기울이지 않아도 규칙에 따르지 싶다.

마지막 정리로, 혹자는 이들 규칙을 지나친 것으로 여기거나 실제 운영 시스템에 적용 불가능하다고 볼지 모르겠다. 그 생각은 틀렸다. 나는 이 책이 출간될 즈음 100,000줄을 이런 식으로 작성한 시스템을 마무리하고 있다. 이 시스템 구축 작업을 하는 프로그래머는 일상적으로 이들 규칙을 따르며 심오한 간결성(deep simplicity)을 온몸으로 끌어안을 때 얼마나 지겨운 개발이 덜어질 수 있는지를 목도하며 서로 너무 즐거워하고 있다.



만약 오브젝트가 지금 인스턴스 변수의 적당한 집합을 캡슐화하고 있지만 그 설계는 여전히 어색하다면,

좀 더 직접적인 캡슐화 위반을 조사해 볼 때입니다. 그냥 단순히 현재 위치에서의 값을 물을 수 있는 동작이라면

해당 인스턴스 변수를 제대로 따라가지 못 할 것입니다. 강한 캡슐화 경계의 바탕에 깔린 사상은 동작의 검색과

배치를 위해 남겨둔 코드를 만질 다른 프로그래머를 오브젝트 모델의 단일한 지점으로 유도하려는 것입니다.

이는 많은 긍정적인 하부 효과를 가져다주는데, 중복 오류의 극적 축소와 새 기능의 구현을 위한 변경의 지역화

개선이 있습니다.

잘 설계된, 그리고 제대로 객체지향적인 관점을 가진 시스템이라면 하나의 문제를 해결하기 위한 소스 코드의 수정은 한번에 끝납니다. 그리고 시스템의 다른 부분에 전혀 영향을 주지 않죠.

물론 이와 같은 얘긴 이상향에 가까운 얘기겠으나, 더 객체지향적일수록 더 유지보수 및 관리가 쉬우며 변경에 강하다고 받아 들일 수 있습니다.

요즘 자주 드는 생각인데,  실제 프로젝트 진행시 [원칙<->현실] 사이에서 트레이드 오프를 잘하는 사람이 고수라는 생각이 듭니다.

 

자바 언어를 익히는 일은 어려운 일이 아니기에 프로그래밍을 쉽게 생각할 수 있으나, 실제 구현시 어떤 원칙과 생각을 가지고 개발하냐에 따라 프로그램의 품질이 갈립니다. 그 차이는 처음에는 느끼기 어려우나 시간이 흐를 수록 확연히 나타나며, 프로젝트의 수명에도 또한 큰 영향을 줍니다.

객체지향체조에 나타나 있는 규칙을 전부 따르긴 현실적으로 힘드나, 내용을 알고 한번쯤 연습해 본다면 도움이 될 거라 생

