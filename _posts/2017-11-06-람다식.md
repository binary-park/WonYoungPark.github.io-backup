---
layout: post
title: "람다식"
subtitle: "Java"
categories: document
tags: java
comments: true
---

### 1. 람다식이란?

최근 들어 함수적 프로그래밍이 다시 부각되고 있는데, 병렬 처리와 이벤트 지향 프로그래밍에 적합하기 때문이다. 그래서 객체 지향 프로그래밍과 함수적 프로그래밍을 혼합함으로써 더욱 효율적인 프로그래밍이 될 수 있도록 프로그램 개발 언어가 변하고 있다.

람다식은 익명함수(anonymous function)을 생성하기 위한 식으로 객체 지향 언어보다는 함수지향 언어에 가깝다. 람다식의 형태는 매개변수를 가진 코드 블록이지만, 런타임 시에 익명 구현 객체를 생성한다.

```
람다식 -> 매개변수를 가진 코드 블록 -> 익명 구현 객체
```

예를 들어 Runnable 인터페이스의 익명 구현 객체를 생성하는 전형적인 코드는 다음과 같다.

```java
Runable runnable = new Runnable() {
    public void run() {}
};
```

위 코드에서 익명 구현 객체를 람다식으로 표현하면 다음과 같다.

```java
Runnable runnable = () -> {...} // 람다식
```

### 2. 람다식 기본 문법

함수적 스타일의 람다식을 작성하는 방법은 다음과 같다.

```java
(타입 매개변수, ...) -> {실행문;}
```

(타입 매개변수, …) 는 오른쪽 중괄호 {} 블록을 실행하기 위해 필요한 값을 제공하는 역할을 한다. 매개 변수의 이름은 개발자가 자유롭게 줄 수 있다. -> 기호는 매개 변수를 이용해서 중괄호 {}를 실행한다는 뜻으로 해석하면 된다. 예를 들어 int 매개변수 a의 값을 콘솔에 출력하기 위해 다음과 같이 람다식을 작성할 수 있다.

```java
(int a) -> {System.out.println(a);}
```

매개 변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 잇기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않는다. 그래서 위코드는 다음과 같이 작성할 수 있다.

```java
(a) -> {System.out.println(a);}
```

하나의 매개 변수만 있다면 괄호()를 생각할 수 있고, 하나의 실행문만 있다면 중괄호{}도 생략할 수 있다. 그래서 위 코드는 다음과 같이 작성할 수도 있다.

```java
a -> System.out.println(a);
```

만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 다음과 같이 빈 괄호()를 반드시 사용해야 한다.

```java
() -> {실행문;}
```

 중괄호 {}를 실행하고 결과값을 리턴해야 한다면 다음과 같이 return 문으로 결과값을 지정할 수 있다.

```java
(x, y) -> {return x + y;}
```

중괄호 {}에 return문만 있을 경우, 람다식에서는 return문을 사용하지 않고 다음과 같이 작성하는것이 정석이다.

```java
(x, y) -> x + y
```



### 3. 타켓 타입과 함수적 인터페이스

람다식의 형태는 매개 변수를 가진 코드 블록이기 때문에 마치 자바의 메소드르 럿ㄴ언하는 것처럼 보여진다. #**자바는 메소드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하기 때문에 람다식은 단순히 메소드를 선언하는 것이 아니라 이 메소드를 가지고 있는 객체를 생성해 낸다.** 그럼 어떤 타입의 객체를 생성하는 것일 까?

```
인터페이스 변수 = 람다식
```

람다식은 인터페이스 변수에 대입된다. 이말은 람다식은 인터페이스의 익명 구현 객체를 생성한다는 뜻이 된다. **인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데,  람다식은 익명 구현 클래스를 생성하고 객체화 한다.** 람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에 람다식이 대입될 인터페이스를 람다식의 타켓 타입이라고 한다.

#### 3.1. 함수적 인터페이스(@FunctionalInterface)

하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타켓 타입이 될 수 있다. **함수적 인터페이스를 작성할 때 두개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이다.** 이 어노테이션이 붙어있는 어노테이션에 두개 이상의 추상메소드가 선언되면 컴파일 오류를 발생시킨다.

```java
@FunctionalInterface
public interface MyFunctionalIntterface {
    public void method();
    public coid otherMethod(); // 컴파일 오류
}
```



### 4. 크래스 멤버와 로컬 변수 사용

람사식의 실행 블로록에는 클래스의 멤버(필드와 메소드) 및 로컬 변수를 사용할 수 있다. 클래스의 멤버는 제약 사항 없이 사용 가능하지만, 로컬 변수는 제약 사항이 따른다.

#### 4.1. 클래스의 멤버 사용

람다식 실행 블록에는 클래스의 멤버인 필드와 메소드를 제약 사항 없이 사용할 수 있다. **하지만 this 키워드를 사용할 때에는 주의가 필요하다. 일반적으로 익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라 람다식을 실행한 객체의 참조이다.** 다음 예제는 람다식에서 바깥 객체와 중첩 객체의 참조를 얻어 필드값을 출력하는 방법을 보여주고 있다. 중첨 객체 Inner에서 람다식을 실행했기 때문에 람다식 내부에서의 this는 중첩 객체Inner이다.

```java
public interface MyfunctionalInterface() {
    public void metthod();
}

public class UsingThis() {
    public int outterField = 10;
    
    void method() {
        // 람다식
        MyFunctionalInterface fi = () -> {
            System.out.println("outterField : " + outterField);
            System.out.println("outterField : " + ThisExample.this.outterField); // 바깥 객체의 참조를 얻기 위해서는 클래스명.this를 사용
            
            System.out.println("innerField : " + innerField);
            System.out.println("innerField : " + this.innerField); // 람다식 내부에서 this는 inner 객체를 참조
            
        }
        fi.method();
    }
}
```

#### 4.2. 로컬 변수 사용

람다식에서 바깥 클래스의 필드나 메소드느 ㄴ제한 없이 사용할 수 있으나, 메소드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 finnal 특성을 가져야 한다.



### 5. 표준 API의 함수적 인터페이스

자바에서 제공되는 표준 API에서 한 개의 추상 메소드를 가지는 인터페이스들은 모두 람다식을 이용해서 익명 구현 객체로 표현이 가능하다.

- Consumer
  - 특징 : 매개값은 있고, 리턴값은 없음
- Supplier
  - 특징 : 매개값을 없고, 리턴값은 있음
- Function
  - 특징
    - 매개값도 잇고, 리턴값도 있음
    - 주로 매개값을 리턴값으로 매핑(타입변환)
- Operator
  - 특징
    - 매개값도 있고, 리턴값도 있음
    - 주로 매개값 연산하고 결과를 리턴
- Predicate
  - 특징
    - 매개값도 있고, 리턴 타입은 boolean
    - 매개값을 조사해서 true/false를 리턴



#### 5.1. Consumer 함수적 인터페이스

Consumer 함수적 인터페이스의 특징은 **리턴값이 없는 accpt() 메서드를 가지고 있다.** accept() 메소드는 단지 매개값을 소비하는 역할만 한다. 여기서 소비한다는 말은 사용만 할 뿐 리턴값이 없다는 뜻이다.

```java
public class ConsumerExcaple {
    public static void main(Stirng[] args) {
        Consumer<Stirng> consumer = t -> System.out.prinln(t + "8");
        consumer.accept("java");
        // java8
        
        BiConsumer<String, String> bigConsumer = (t, u) -> System.out.println(t + u);
        bigConsumer.accept("java", "8");
        // java8
        
        DubleConsumer dobleConsumer = d -> System.out.println("java" + d);
        dobuleConsumer.accept(8.0);
        // java8.0
    }
}
```

#### 5.2. Supplier 함수적 인터페이스

Supplier함수적 인터페이스의 특징은 매개 변수가 없고, 리턴값이 있는 getXXX() 메소드를 가지고 있다. 에 모소드들은 실행 후 호출한 곳으로 데이터를 리턴(공급) 하는 역할을 한다.

```java
public class SupplierExample {
    public static void main(String[] args) {
        IntSupplier intSupplier = () -> {
            int num = (int) (Math.random() * 6) + 1;
            return num;
        };
        
        int num = intSupplier.getAsInt();
        System.out.println(num);
    }
}
```



#### 5.3. Function 함수적 인터페이스

매개값과 리턴값이 있는 applyXXX() 메소드를 가지고 있다. 이 메소드들은 매개값을 리턴값으로 매핑(타입변환)하는 역할을 한다.